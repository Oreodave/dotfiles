#+TITLE: Oreodave's Emacs configuration
#+AUTHOR: Oreodave
#+DESCRIPTION: My Doom Emacs configuration!
#+PROPERTY: header-args :results none

* Preclude
- This is my [[https://github.com/hlissner/doom-emacs][Doom Emacs]] configuration.
- Use it for most of my code editing and development needs.
- Incredibly versatile tool in my inventory.
- Has me like this half the time (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØ‚îª‚îÅ‚îª
* Init
Initialize literate config and setup some basic variables
** Bootstrap
Load the literate.el file to start parsing.
#+BEGIN_SRC elisp
(load (expand-file-name (concat doom-private-dir "bin/literate.el")))
#+END_SRC
** Doom Variables
- Set the doom localleader to "," because it's faster
- Using the font [[https://sourcefoundry.org/hack/][Hack]]
#+BEGIN_SRC elisp
(after! core-keybinds
  (map! :leader "," nil)
  (setq doom-localleader-key "SPC ,")
  (setq doom-theme 'doom-molokai)
  (setq doom-font (font-spec :family "Hack" :size 17)))
#+END_SRC
** Other variables
Some quality of life things and others that I couldn't really put in one category
- Using line-numbers that are relative now instead of nothing.
- Set org directory
- Add libgen to search providers
#+BEGIN_SRC elisp
(setq completion-ignore-case t)
(setq truncate-lines t)
(setq display-line-numbers-type nil)
(setq bookmark-default-file (expand-file-name (concat doom-private-dir "bookmarks")))
(setq-default frame-title-format '("%b - Emacs"))
(add-to-list 'default-frame-alist '(alpha . 85))
(cl-pushnew '("Libgen" "http://gen.lib.rus.ec/search.php?req=%s") +lookup-provider-url-alist :key #'car :test 'string=)
#+END_SRC
* Package Config
Config for or based heavily around specific packages that I find very important
** DAP
*** Function
First to setup is a routine for setting up all the dap-panes for debugging.
Easier to do than just running all those functions manually
- Routine sets up the panes that I like to use, instead of M-x'ing it
- *<SPC>cD* starts up the routine
#+BEGIN_SRC elisp
(after! dap-mode
  (defun dx:debug ()
    (interactive)
    (dap-ui-mode)
    (dap-ui-locals)
    (dap-ui-sessions)))
#+END_SRC
*** Keybind
#+BEGIN_SRC elisp
(map!
 :after dap-mode
 :leader
 :desc "Start debugging setup" "cD" #'dx:debug)
#+END_SRC
** Dashboard
My very own dashboard config using doom dashboard, with these features:
- Custom load message
- Custom splash image and dashboard buffer name
- Custom dashboard sections for myself

*** Benchmark display
Redo the display-benchmark function to display a different message
#+BEGIN_SRC elisp
(defun doom-display-benchmark-h (&optional return-p)
  "Display a benchmark, showing number of packages and modules, and how quickly
they were loaded at startup.

If RETURN-P, return the message as a string instead of displaying it."
  (funcall (if return-p #'format #'message)
           "Œµmacs loaded %d packages, %d modules in %.03fs"
           (- (length load-path) (length doom--initial-load-path))
           (if doom-modules (hash-table-count doom-modules) 0)
           (or doom-init-time
               (setq doom-init-time
                     (float-time (time-subtract (current-time) before-init-time))))))
#+END_SRC

*** Image and buffer name
Set the splash-image and dashboard buffer name
Space image comes from [[https://flaticon.com][website]]
#+BEGIN_SRC elisp
(setq fancy-splash-image "~/Pictures/SplashScreens/space2.png") ; splash image
(setq +doom-dashboard-name "*dashboard*")
#+END_SRC
*** Dashboard items
Set the dashboard functions (segments in overall buffer), set the sections of the interactive menu as well.
#+BEGIN_SRC elisp
(setq +doom-dashboard-functions ; limit the dashboard items
      '(doom-dashboard-widget-banner
        doom-dashboard-widget-loaded
        doom-dashboard-widget-shortmenu))

(setq +doom-dashboard-menu-sections ; Set a specific amount of items
      '(("Open org-agenda"
         :icon (all-the-icons-octicon "calendar" :face 'font-lock-keyword-face)
         :when (fboundp 'org-agenda)
         :action org-agenda)
        ("Check the weather"
         :icon (all-the-icons-wicon "rain" :face 'font-lock-keyword-face)
         :action dx:weather)
        ("Jump to bookmark"
         :icon (all-the-icons-octicon "bookmark" :face 'font-lock-keyword-face)
         :action bookmark-jump)))
#+END_SRC
** Spelling checker
Keybinds to org-mode for flyspell package
#+BEGIN_SRC elisp
(map!
 :after (flyspell org)
 :localleader
 :map org-mode-map
 :prefix "w"
 :desc "Correct current word" "c" #'flyspell-correct-at-point
 :desc "Autocorrect word"     "a" #'flyspell-auto-correct-word
 :desc "Goto next error"      "w" #'flyspell-goto-next-error)
#+END_SRC
** Projectile
Add CMakeLists.txt to projectile-project-roots.
#+BEGIN_SRC elisp
(after! projectile
  (cl-pushnew "CMakeLists.txt" projectile-project-root-files :test 'string=)
  (setq projectile-tags-command
        "ctags -e -R --exclude=dist --exclude=.ccls --exclude=.ccls-cache"))
#+END_SRC
** Prettify symbols
Configuration for the module (pretty-code).
*** Setup symbols
Some symbols aren't present in the current doom version, or my fonts are screwing up, so I wrote them here.
Maybe a bit of a bandage over broken glass, but still at least it's something.
#+BEGIN_SRC elisp
(setq +pretty-code-symbols
      '(:name "¬ª"
        :src_block "¬ª"
        :src_block_end "¬´"
        :quote "‚Äú"
        :quote_end "‚Äù"
        :lambda "Œª"
        :def "∆í"
        :composition "‚àò"
        :map "‚Ü¶"
        :null "‚àÖ"
        :true "ùïã"
        :false "ùîΩ"
        :int "‚Ñ§"
        :float "‚Ñù"
        :str "ùïä"
        :bool "ùîπ"
        :not "¬¨"
        :in "‚àà"
        :not-in "‚àâ"
        :and "‚àß"
        :or "‚à®"
        :for "‚àÄ"
        :some "‚àÉ"
        :return "‚üº"
        :yield "‚üª"
        :tuple "‚®Ç"
        :pipe "|"
        :dot "‚Ä¢"))
#+END_SRC

The 'x' symbol in the =+pretty-code-fira-code-font-ligatures= is annoying, and unneeded.
So I remove it.
#+BEGIN_SRC elisp
(assoc-delete-all "x" +pretty-code-fira-code-font-ligatures #'string=)
#+END_SRC
*** Pretty symbols
Setup pretty symbols specifically for C++.
I import the string type via `using std::string` which isn't supported in standard doom.
So I add support for it.
#+BEGIN_SRC elisp
(after! cc-mode
  (set-pretty-symbols!
    '(c-mode c++-mode)
    :return "return"
    :or "||"
    :and "&&"
    :not "!"
    :bool "bool"
    :str "string"
    :str "std::string"
    :float "float"
    :int "int"
    :false "false"
    :true "true"
    :null "nullptr"))
#+END_SRC
** Calc
*** Configuration
#+BEGIN_SRC elisp
(use-package! calc
  :config
  (setq calc-angle-mode 'rad)
  (map!
   :leader
   :desc "Calc" ":" #'calc))
#+END_SRC
*** Calctex
Added some calc mode config. An incredibly powerful tool.
#+BEGIN_SRC elisp
(use-package calctex
  :defer t
  :config
  (add-hook 'calc-mode-hook #'calctex-mode))
#+END_SRC
** Dired and ranger
#+BEGIN_SRC elisp
(after! ranger
  (setq ranger-cleanup-eagerly t)
  (setq ranger-show-hidden t))
#+END_SRC
** Compilation
Add keybind to recompile (inside the buffer)
#+BEGIN_SRC elisp
(map!
 (:map 'compilation-mode-map
  :n "u" #'recompile))
#+END_SRC
* Language Config
Configuration for various languages which I feel can be useful
** C-style languages
Configuration for C and C++.
*** User c-style
Emacs doesn't have the full range of styles that I want, so lemme just do it myself.
#+BEGIN_SRC elisp
(after! cc-mode
  (c-add-style
   "user"
   '((c-basic-offset . 2)
     (c-comment-only-line-offset . 0)
     (c-hanging-braces-alist (brace-list-open)
                             (brace-entry-open)
                             (substatement-open after)
                             (block-close . c-snug-do-while)
                             (arglist-cont-nonempty))
     (c-cleanup-list brace-else-brace)
     (c-offsets-alist
      (statement-block-intro . +)
      (knr-argdecl-intro . 0)
      (substatement-open . 0)
      (substatement-label . 0)
      (access-label . 0)
      (label . 0)
      (statement-cont . +))))
  (setq c-default-style "user"))
#+END_SRC
** CSharp
- I have custom installed the omnisharp roslyn executable, so I'd rather use that
#+BEGIN_SRC elisp
(after! csharp-mode
  (setq omnisharp-server-executable-path "~/Bin/repos/omnisharp-roslyn/run"))
#+END_SRC
*** Unit test over whole projects
- Implemented my own function which piggy backs counsel etags to globally search tags for test specific context, then goes to it and uses an omnisharp test command to unit test it.
  Basically global test search in C# projects.
  To use this, just make sure you have tags compiled and that all your tests are written as some public void *name* _Test (i.e. they are appended with _Test so that the pattern can be matched)
#+BEGIN_SRC elisp
(after! (csharp-mode counsel-etags)
  (defun dx:csharp/get-unit-test-in-project ()
    "Unit test anywhere using CTags or ETags and C#"
    (interactive)
    (let* ((tags-file (counsel-etags-locate-tags-file))
           (cands (counsel-etags-collect-cands "void.*Test" t buffer-file-name)))
      (let ((item (completing-read "Choose test: " cands)))
         ;; From the counsel-etags file-open-api function
         (when (string-match "\\`\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'" item)
           (let*
               ((file (match-string-no-properties 1 item))
                (linenum (match-string-no-properties 2 item))
                ;; always calculate path relative to TAGS
                (default-directory (counsel-etags-tags-file-directory)))
             (counsel-etags-push-marker-stack (point-marker))
             (find-file file)
             (counsel-etags-forward-line linenum)
             (omnisharp-unit-test-at-point)))))))
#+END_SRC
*** Redo omnisharp-emit-results
- Reimplemented omnisharp-emit-results to emit stdout regardless of whether the
  test failed or not
#+BEGIN_SRC elisp
(after! (csharp-mode omnisharp)
  (defun omnisharp--unit-test-emit-results (passed results)
    "Emits unit test results as returned by the server to the unit test result buffer.
PASSED is t if all of the results have passed. RESULTS is a vector of status data for
each of the unit tests ran."
                                        ; we want to clean output buffer for result if things have passed otherwise
                                        ; compilation & test run output is to be cleared and results shown only for brevity

    (omnisharp--unit-test-message "")

    (seq-doseq (result results)
      (-let* (((&alist 'MethodName method-name
                       'Outcome outcome
                       'ErrorMessage error-message
                       'ErrorStackTrace error-stack-trace
                       'StandardOutput stdout
                       'StanderError stderr) result)
              (outcome-is-passed (string-equal "passed" outcome)))

        (omnisharp--unit-test-message
         (format "[%s] %s "
                 (propertize
                  (upcase outcome)
                  'font-lock-face (if outcome-is-passed
                                      '(:foreground "green" :weight bold)
                                    '(:foreground "red" :weight bold)))
                 (omnisharp--truncate-symbol-name method-name 76)))

        (if error-stack-trace
            (omnisharp--unit-test-message error-stack-trace))

        (unless (= (seq-length stdout) 0)
          (omnisharp--unit-test-message "Standard output:")
          (seq-doseq (stdout-line stdout)
            (omnisharp--unit-test-message stdout-line)))

        (unless (= (seq-length stderr) 0)
          (omnisharp--unit-test-message "Standard error:")
          (seq-doseq (stderr-line stderr)
            (omnisharp--unit-test-message stderr-line)))
        ))

    (omnisharp--unit-test-message "")

    (if (eq passed :json-false)
        (omnisharp--unit-test-message
         (propertize "*** UNIT TEST RUN HAS FAILED ***"
                     'font-lock-face '(:foreground "red" :weight bold)))
      (omnisharp--unit-test-message
       (propertize "*** UNIT TEST RUN HAS SUCCEEDED ***"
                   'font-lock-face '(:foreground "green" :weight bold)))
      )
    nil))
#+END_SRC
*** Map for C# mode
#+BEGIN_SRC elisp
(after! csharp-mode
  (map! ; CSharp Keybinds
   :map csharp-mode-map
   :localleader
   :desc   "Format buffer"            "="    #'omnisharp-code-format-entire-file
   (:prefix "t"
    :desc "Select Test in Project"    "t"   #'dx:csharp/get-unit-test-in-project)))
#+END_SRC
** Python
- I do python development for Python3, so I need to set the flycheck python checker, as well as the interpreter, to be Python3
- Most of my python work is in scripts or ideas, so I don't need extensive testing utilities or anything like that
- I run my python code a LOT and thus need commands for sending bits or whole scripts into the REPL
#+BEGIN_SRC elisp
(after! python
  (setq python-version-checked t)
  (setq python-python-command "python3")
  (setq python-shell-interpreter "python3")
  (setq flycheck-python-pycompile-executable "python3")

  (map! ; Python keybinds
   :map python-mode-map
   :localleader
   :desc "Start python minor" "c" #'run-python
   :desc "Format buffer"      "=" #'py-yapf-buffer
   (:prefix "s"
    :desc "Send region REPL" "r" #'python-shell-send-region
    :desc "Send buffer"      "b" #'python-shell-send-buffer
    :desc "Send function"    "f" #'python-shell-send-defun)))
#+END_SRC
** TypeScript
- Typescript (in my opinion) should be indented by 2
- Setup the LSP server on the lsp-language-id-config in case it hasn't already
#+BEGIN_SRC elisp
(after! typescript-mode
  (setq typescript-indent-level 2)
  (setq tide-format-options '(:indentSize 2 :tabSize 2))
  (after! lsp
    (cl-pushnew '(typescript-mode . "typescript") lsp-language-id-configuration :key #'car)
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection "typescript-language-server --stdio")
      :major-modes '(typescript-mode)
      :server-id 'typescript))))
#+END_SRC
** FSharp
#+BEGIN_SRC elisp
(after! fsharp
  (setq inferior-fsharp-program "dotnet fsi --readline"))
#+END_SRC
** Org
Org configuration to maximise org workflow.
*** Org variables
Setup the agenda-files and the org-directory.
#+BEGIN_SRC elisp
(after! org
  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook #'org-toggle-latex-fragment)
  (setq org-directory "~/Text"
        org-agenda-files '("~/Text/")
        org-src-window-setup 'split-window-right
        org-superstar-headline-bullets-list '("‚óâ" "‚Ä£" "‚ßà" "‚¨†")
        org-log-repeat 'note))
#+END_SRC
*** Fragtog
#+BEGIN_SRC elisp
(use-package! org-fragtog
  :config
  (add-hook 'org-mode-hook #'org-fragtog-mode))
#+END_SRC
*** Thesaurus
Powerthesaurus installation, added a keybind in org-mode for looking up words.
#+BEGIN_SRC elisp
(use-package! powerthesaurus
  :after-call (org-mode)
  :defer-incrementally (org)
  :config
  (map!
   :localleader
   :map org-mode-map
   :prefix "w"
   :desc "Thesaurus" "t" #'powerthesaurus-lookup-word-at-point))
#+END_SRC
Powerthesaurus for thesaurus on writer files
*** Org keymap
- I like using org-export often, so bind it to a primary bind.
- Loading latex fragments is nice
#+BEGIN_SRC elisp
(map! ; Org keybinds
 :after org
 :map org-mode-map
 :localleader
 :desc "Org dispatch"        "e" #'org-export-dispatch
 :desc "Org LaTeX"           "E" #'org-latex-export-as-latex)
#+END_SRC
** Haskell
#+BEGIN_SRC elisp
(map!
 :after haskell-mode
 :map haskell-mode-map
 :localleader
 "l" #'haskell-process-load-file
 "r" #'haskell-process-reload
 "o" #'haskell-process-start)
#+END_SRC
* Key-map
General keymap
** Personal
- Prefix "SPC m" (rebound from local-leader) that will hold personal keybinds for functions that I like using
- Mostly opening directories I use a lot or doing custom stuff that I can't really put in anything in particular
#+BEGIN_SRC elisp
(map!
 :leader
 :prefix ("m" . "personal") ; Personal
 :desc   "Open Reviews"       "a"     #'(lambda () (interactive) (doom-project-find-file "~/Text/Reviews"))
 :desc   "Open books"         "b"     #'(lambda () (interactive) (dired (concat org-directory "/Books"))); I like my books
 :desc   "Open school dir"    "s"     #'(lambda () (interactive) (dired (expand-file-name "~/School")))
 :desc   "Open notes"         "n"     #'(lambda () (interactive) (dired org-directory))
 :desc   "Open code"          "c"     #'(lambda () (interactive) (dired (expand-file-name "~/Code")))
 :desc   "Open weather"       "w"     #'dx:weather
 :desc   "Change theme"       "t"     #'dx:themes/set-new-theme ; From my own collection
 :desc   "Generate template"  "g"     #'+gentemplate/generate-template ; From my own collection
 (:after pdf-view
  :desc "Goto page on pdf"   "p"     #'pdf-view-goto-page)
 :desc   "Reload emacs"       "r"     #'dx:reload) ; Reload is necessary
#+END_SRC
** Counsel
- Counsel keybind config
- Mostly just convenience stuff that happens to use counsel
#+BEGIN_SRC elisp
(map!
 :leader
 :after counsel ; Counsel or ivy
 :desc   "M-x"                "SPC"  #'execute-extended-command ; Redefine as M-x because of my muscle memory with spacemacs
 (:prefix ("s" . "search")
  :desc "RipGrep!"           "r"     #'counsel-rg ; Ripgrep is faster than Ag in most cases and makes me feel cool
  :desc "Search Tags"        "t"     #'counsel-etags-find-tag)); is quicker to do than <SPC>/b, for something that is done so often
#+END_SRC
** Window
- Keybinds to do with windows
- SPC wc < SPC wd
- Some ace-window config in the window keybind prefix
#+BEGIN_SRC elisp
(map!
 :leader
 :prefix ("w" . "window") ; Windows
 :desc "Close window"       "d"       #'+workspace/close-window-or-workspace ; is slightly closer together than <SPC>wc
 :desc "Switch window"      "w"       #'ace-window ; is also used in spacemacs so I'd rather use this
 :desc "Swap windows"       "S"       #'ace-swap-window) ; allows me to switch windows more efficiently than before, better than just motions
#+END_SRC
** Code
- Some keybinds for the code prefix which help me with coding or working with code, particularly LSP
#+BEGIN_SRC elisp
(map!
 :leader
 :prefix ("c" . "code") ; Code
 :desc "Compile"            "c"       #'compile
 :desc "Recompile"          "C"       #'recompile
 :desc "Compile via make"   "m"       #'+make/run
 :desc "Undo tree"          "u"       #'undo-tree-visualize
 :desc "Narrow to function" "n"       #'+narrow/toggle-narrow
 (:after format-all
  :desc "Format code"       "="       #'format-all-buffer)
 (:after lsp
  :desc "Format code lsp"   "f"       #'+default/lsp-format-region-or-buffer
  :desc "Execute action"    "a"       #'lsp-execute-code-action)
 (:after dap-mode
  :desc "Debug hydra"       "h"       #'dap-hydra))
#+END_SRC
** Projectile
- Projectile config, for leader and for project prefix
#+BEGIN_SRC elisp
(map!
 :leader
 :after projectile
 :desc   "Switch to p-buffer" ">"     #'projectile-switch-to-buffer ; Opposing <SPC>< which counsel's all buffers
 (:prefix ("p" . "project")
  :desc "Regen tags"         "g"     #'projectile-regenerate-tags
  :desc "Open project files" "f"     #'projectile-find-file))
#+END_SRC
** Fonts
- Fonts keybinds (prefix "z") for messing with fonts temp on a buffer
- Really useful when I need to zoom into something for whatever reason
#+BEGIN_SRC elisp
(map!
 :leader
 :prefix ("z" . "font") ; Fonts
 :desc "Increase font"  "+"           #'doom/increase-font-size
 :desc "Decrease font"  "-"           #'doom/decrease-font-size
 :desc "Adjust font"    "z"           #'text-scale-adjust)
#+END_SRC
** Frames
- Keybinds for frame manipulation:
  - Generate new frames from current buffer
  - Generate new frames from a specific buffer
  - Delete frames
  - Switch frames
#+BEGIN_SRC elisp
(map!
 :leader
 :prefix ("F" . "frame") ; Frames
 :desc "Kill frame"           "d"     #'delete-frame
 :desc "Current buffer frame" "m"     #'make-frame
 :desc "Choose Buffer frame"  "n"     #'display-buffer-other-frame
 :desc "Switch frames"        "o"     #'other-frame)
#+END_SRC
** Other
*** Leader
- Miscellaneous leader bindings that don't really fit into any particular item
#+BEGIN_SRC elisp
(map!
 :leader
 :desc   "Shell command"      "!"       #'async-shell-command ; Better than M-!
 (:prefix ("b" . "buffers") ; Buffers
  :desc "Close buffer"       "d"       #'doom/kill-this-buffer-in-all-windows)
 (:prefix ("f" . "files")
  :desc "Find in dotfiles"   "p"       #'(lambda () (interactive) (doom-project-find-file "~/Dotfiles")))
 (:prefix ("o" . "open")
  (:when (featurep! private rss newsticker)
   :desc "Open newsticker"    "n"       #'+rss/open-newsticker
   :desc "Close newsticker"   "N"       #'+rss/close-newsticker)
  (:after org
   :desc "Calendar"           "c"       #'=calendar))
 (:prefix ("n" . "notes")
  :desc "Open notes in dired" "-"      #'(lambda () (interactive) (dired org-directory))))
#+END_SRC
*** Non-leader
#+BEGIN_SRC elisp
(defun dx:newline (&optional BACKWARD)
  (interactive)
  (message "%s" BACKWARD)
  (let ((old (point)))
    (cond ((and BACKWARD (= BACKWARD 1)) (+default/newline-above))
          (t (+default/newline-below)))
    (goto-char (+ old 1))
    (evil-normal-state)))

(map!
 :n "TAB" #'evil-jump-item
 :n "M-v" #'dx:newline
 :n "M-V" #'(lambda () (interactive) (dx:newline 1))
 :v "M-c" #'count-words-region
 :n "M-s" #'occur)
#+END_SRC
